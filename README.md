Advent of Clash 2025
====================

This repository contains FPGA designs that solve the problems from
[Advent of Code 2025], written in the hardware description language
[Clash]. Currently, only contains code for days 3 and 7.

I was heavily inspired by [Tristan de Cacqueray's great blog post][aof]
where he explains in detail not just his solutions, but also the Clash
basics needed to understand what's going on. If you've read his post,
you should be able to understand this repository as well.

Input and output
----------------

Each solution is a separate FPGA configuration that communicates with
the outside world with a serial link, at a rate of 115,200 baud using
8 data bits. There's a client program included for uploading the
original AoC inputs, but you can basically just copy-paste them into a
serial terminal. The result is sent back over serial in human-readable
format.

Build system
------------

I've tested it on real hardware with an [ULX3S] and a [Nexys A7].
Shake rules are included to synthesize the solution designs for a given
problem, e.g. problem 03, on the ULX3S, run the following command:

```
./mk P03:ulx3s-85f:bitfile
```

Or to build problem 07's solution for the A7:

```
./mk P07:nexys-a7-50t:bitfile
```

There are also build rules for uploading the resulting bitfile to the
device :

```
./mk P03:ulx3s-85f:upload
```


Day #3: Lobby
-------------

For [day 3], we are given a sequence of length _n_ and have to find a
subsequence of length _k_ that is maximal by the lexicographic
ordering. The choice of _n_ and _k_ is baked in at synthesis time.

Because the input has just _n = 100_ elements, we can keep the whole
thing in a register array.  We can then find the maximum element in
the array in _log₂ n_ cycles by repeatedly overwriting the _iᵗʰ_
element with the maximum of the _2iᵗʰ_ and _(2i+1)ᵗʰ_ elements. We
repeat this _k_ times, each time only looking at elements after the
previous maximum. After all _k_ digits are found, the result is added
to a running total in [BCD], and that running total is emitted through
the serial output after every line.

I didn't really bother making the BCD add operation use as much
resource as available; we simply do it one digit at a time. This could
be sped up relatively a lot by doing as many digits as fits into the timing
schedule, but in absolute terms it's still just 15 cycles for each
input line; serial communication is much slower.

Overall, with _n = 100_, _k = 12_ and a running sum of 15 digits, on
the ULX3S the toolchain reports a maximum frequency of 119 MHz. 

Day #7: Laboratories
--------------------

For a manifold of width _n_, we keep a state of _n_ numbers that
stores how many different timelines arrive at each cell. We can
process each input row online: empty spaces don't change the value
from above, splitters add the value above to the two downward-diagonal
cells. If we keep a buffer of two cells, we can do this without
needing to ever go back to an already processed cell in the next row;
i.e. we can always just produce the next cell value based on the
current above cell value, shift everything by one, repeat.

After each input row is processed, the number of different timelines
is the sum of the numbers in the state vector. We can calculate that
sum while we process the input, to avoid a deep adder tree.

This should result in a wide, but shallow circuit: _n_ values (let's
say 64 bit numbers) daisy chained by the shifter, and a couple of
adders to process splitters and keep track of the number of splitter
hits and the total timelines. However, I wasn't able to synthesize
this on the ULX3S for 100 MHz, which I find baffling. I even tried
using just 48 bits instead of 64 (48 bits seem enough to solve the
test input), to no avail.

I ended up running this on the [Nexys A7], where Vivado had no issues
synthesizing it for 100 MHz. It will probably be a good idea to go
back to this issue at some point and figure out if this is a problem
with my Clash code, a problem with the Verilog generated by Clash,
or a Yosys/NextPNR deficiency, or maybe it really truly is too deep
for the ULX3S's ECP5 FPGA.


[Advent of Code 2025]: https://adventofcode.com/2025
[Clash]: https://clash-lang.org/
[aof]: https://midirus.com/blog/advent-of-fpga
[Day 3]: https://adventofcode.com/2025/day/3
[ULX3S]: https://radiona.org/ulx3s/
[Nexys A7]: https://digilent.com/reference/programmable-logic/nexys-a7/start
[BCD]: https://en.wikipedia.org/wiki/Binary-coded_decimal
[`fujprog`]: https://github.com/kost/fujprog
